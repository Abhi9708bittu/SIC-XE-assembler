# SIC/XE Assembler by Abhishek Raj,IITR
implemented in c++ language
 PASS 1-
  pass1.cpp is the first pass of the assembler, where it reads the input source file and generates an intermediate file along with an error file. It checks each source file line to see if it is a comment line. If it is a comment, the assembler writes it to the intermediate file and updates the line number. If not a comment, the assembler checks if it is a START opcode and updates the start address and LOCCTR accordingly.

After checking the symbol and opcode, the assembler updates the data to be written to the intermediate file. It then proceeds with a loop that continues until the end of the source file is reached. For each line, the assembler checks if it is a comment line. If it is, it is printed to the intermediate file, and the line number is updated. If it is not a comment line, the assembler verifies the opcode and updates the LOCCTR accordingly.
For opcodes like USE, the assembler inserts a new BLOCK entry in the BLOCK map. For LTORG, a function in pass1.cpp is called to print the literal pool present till that time. For ORG, the assembler points out the LOCCTR to the operand value given, and for EQU, it checks whether the operand is an expression, and if it is valid, it enters the symbols in the SYMTAB. If the opcode does not match with any of the above-given opcodes, the assembler prints an error message in the error file.
Once the loop ends, the assembler stores the program length and prints the SYMTAB, LTTAB, and other tables if present.

Accordingly, we then update our data to be written in the intermediate file. After the loop ends, we store the program length and then go on to print the SYMTAB, LTTAB, and other tables if present. 

The to_handle_the_LTORG() function is called by the assembler when it encounters the LTORG opcode in the input file during Pass 1. This function takes an argument, which refers to the literal pool present till the current line is processed in Pass 1.
Using an iterator, the function first prints all the literals in the LITTAB (literal table) until that point in the input file. Then it updates the line number to the following line in the intermediate file. Next, the function checks if any literals do not have an address assigned yet. For such literals, the present value of LOCCTR is stored in the LITTAB, and LOCCTR is incremented based on the literal size. This function is used to handle the LTORG directive, which indicates the beginning of a new literal pool in the program. The LTORG directive causes all the literals present till that point in the input file to be assigned an address in memory. It also indicates the beginning of a new literal pool that may be present in the program.

PASS 2 -
In pass2.cpp, the assembler takes the intermediate file generated by pass1 as input and develops the final object program. If the assembler is unable to open the file, it will print an error message in the error file. The first line of the intermediate file is read, and until the lines are comments, they are taken as input and printed to the intermediate file, and the line number is updated. If the opcode is "START," the start address is initialized as the LOCCTR, and the line is written to the listing file. Then, the assembler checks whether the number of sections in the intermediate file is greater than one. If it is, the program length is updated as the length of the first control section; otherwise, it is kept unchanged. For instructions with immediate addressing, the assembler writes the modification record. For writing the end record, there is a function in pass2.cpp that takes in the final address of the program as an argument and writes the end record to the object program.

function_for_reading_till_TAB(): takes in the string as input and reads the string until tab(‘\t’) occurs. 
 
function_for_reading_the_intermediate_file():  Takes in location counter, opcode, operand, and label. If the line is a comment returns true and takes in the following input line.  
 



